const
-1
cjmp
@start

( Machine words )
.codeword constw const 4 .end
.codeword +w !constw + .end
.codeword +1 const 1 + .end
.codeword -1 const 1 - .end
.codeword !+1 dup @ const 1 + swap ! .end

( Reserve 32 bytes for the buffer of our 'word' word. )
.var word-buffer 0 .end
nop nop nop nop
nop nop nop nop
nop nop nop nop
nop nop nop nop
nop nop nop nop
nop nop nop nop
nop nop nop nop
nop nop nop nop
.var word-cursor 0 .end

.codeword reset-word-cursor const 0 !word-cursor ! .end
.codeword store-in-word
  !word-buffer !word-cursor @ !+w + b!
  !word-cursor !!+1
.end
.codeword finish-word !word-cursor @ !word-buffer ! !reset-word-cursor .end
.codeword is-blank? const 33 < .end
.codeword non-blank-key
  key dup !is-blank? ~ cjmp @nbk1
  drop const -1 cjmp @_dictnon-blank-key :nbk1
.end
.codeword word
  !non-blank-key
  :word1 !store-in-word
  key dup !is-blank? ~ cjmp @word1
  drop !finish-word !word-buffer
.end

.var emit-word-cursor 0 .end
.codeword reset-emit-word-cursor const 0 !emit-word-cursor ! .end
.codeword emit-word
  !reset-emit-word-cursor
  :emit-word1 !word-buffer @ !emit-word-cursor @ > ~ cjmp @emit-word2
  !word-buffer !emit-word-cursor @ !+w + b@ emit
  !emit-word-cursor !!+1
  const -1 cjmp @emit-word1
  :emit-word2
.end

.codeword pow
  dup const 0 = cjmp @pow-1
  swap dup rput swap
:pow-loop
  dup const 2 < cjmp @pow-end
  swap
  rpop dup rput *
  swap const 1 -
  const -1 cjmp @pow-loop
:pow-end
  drop
  rpop
  drop
  ret
:pow-1
  drop
  drop
  const 1
.end

.codeword number?
  dup const 47 > & const 58 <
.end

.codeword negative-number?
  !word-buffer !+w b@
  const 45 =
.end

.codeword unit
  cjmp @unit-t
  const 1
  ret
:unit-t
  const -1
.end

.codeword minus?
  const 45 =
.end

.codeword number
  !negative-number?
  dup const -1 * rput	( Skip the first char if it is '-' )
  !unit	       	 	( 1 or -1 if '-' )
  const 0		( Init result )
:number-loop
  !word-buffer !+w rdup + b@				( Read char at offset rdup )
  dup !number? ~ cjmp @number-err
  const 48 -
  const 10 !word-buffer @ const 1 - rdup - !pow * +	( Scale digit at offset )
  rpop const 1 + rput
  rdup !word-buffer @ < cjmp @number-loop
  *  		  ( Negate if word started with '-' )
  const 0	  ( 0 to indicate no error )
  rpop drop
  ret
:number-err
  drop drop drop	( Cleanup )
  rpop drop
  const -1		( -1 to indicate error )
.end

.codeword digit-to-char
  const 10 %	( Get last digit )
  const 48 +	( Add '0' to it )
.end

.codeword digit-count
  dup const -1 > const 1 +
  swap
  
:digit-count-loop
  swap const 1 + swap
  const 10 /
  dup const 0 = ~ cjmp @digit-count-loop
  drop
.end

.codeword last-digit-to-word
  dup dup
  !digit-count const 1 -
  swap !digit-to-char
  swap !+w !word-buffer + b!
  const 10 /
.end
.codeword number-to-word
  dup !digit-count	( Get number of digits )
  !word-buffer !  	( Store future len in word-buffer )

:number-to-word-loop
  !last-digit-to-word
  dup const 0 > cjmp @number-to-word-loop

  drop !word-buffer
.end

.codeword char-at
  !-1 !+w + b@
.end

( TODO: Implement find to return a dictionary pointer )
.codeword word=
  dup b@
  dup rput
  !word-buffer @
  = ~ cjmp @word=-false

  rpop
( TODO: Move to mem= word )
:word=-loop
  rput
  dup rdup + b@
  !word-buffer rdup !char-at
  = ~ cjmp @word=-false
  ( Compare length and return false if != )
  ( Walk through each character and compare them )
  rpop !-1 dup !constw < ~ cjmp @word=-loop
  
  drop drop const -1 ret
  
:word=-false
  rpop drop drop const 0
.end

.codeword prev-word !+1 @ .end

.codeword find
  !latest
  
:find-loop
  dup const 0 = cjmp @find-end
  dup !+1 !word= cjmp @find-end
  !prev-word const -1 cjmp @find-loop

:find-end
.end

( Built-in variables )
.var state 0 .end
.var here @here-label .end
.var base 10 .end

( Built-in constants
# VERSION         Is the current version of this FORTH.
# R0              The +ress of the top of the return stack.
# DOCOL           Pointer to DOCOL.
# F_IMMED         The IMMEDIATE flag's actual value.
# F_HIDDEN        The HIDDEN flag's actual value.
# F_LENMASK       The length mask in the flags/len byte.
)

.const konstantin 77 .end

( .codeword main !word drop !emit-word exit .end )
( .codeword main const 10 const 6 !pow .end )
( .codeword main !word drop const 9999 drop !number drop .end )
( .codeword main const 34 !number-to-word
  !word-buffer @
(  !word-buffer !+w b@ emit )
(  !word-buffer !+w const 1 + b@ emit )
  !emit-word
.end )

( .codeword main !word drop
 const @word-buffer !+w const 9999 drop !word= .end )

( .codeword main !konstantin !here @ !latest @ .end )
.codeword main !word drop const 9999 !find .end


( !!! No word definition shall stand beyond this mark. !!! )
( Except this one. )
.var latest @latest .end

:start
call
@_dictmain
exit

( TODO:
- Support labels in .var macro
- Implement "find"
)


( !!! No code shall reach beyond this point or it will be overwritten. !!! )
:here-label
