const
-1
cjmp
@start

( Machine words )
.codeword +w const 4 + .end
.codeword !+1 dup @ const 1 + swap ! .end

( Reserve 11 bytes for the buffer of our 'word' word. )
.var word-buffer 0 .end
nop nop nop nop
nop nop nop nop
nop nop
.var word-cursor 0 .end

.codeword reset-word-cursor const 0 !word-cursor ! .end
.codeword store-in-word
  !word-buffer !word-cursor @ !+w + b!
  !word-cursor !!+1
.end
.codeword finish-word !word-cursor @ !word-buffer ! !reset-word-cursor .end
.codeword is-blank? const 32 = .end
.codeword non-blank-key
  key dup const 32 = ~ cjmp @nbk1
  drop const -1 cjmp @_dictnon-blank-key :nbk1
.end
.codeword word
  !non-blank-key
  :word1 !store-in-word
  key dup !is-blank? ~ cjmp @word1
  drop !finish-word !word-buffer
.end

.var emit-word-cursor 0 .end
.codeword reset-emit-word-cursor const 0 !emit-word-cursor ! .end
.codeword emit-word
  !reset-emit-word-cursor
  :emit-word1 !word-buffer @ !emit-word-cursor @ > ~ cjmp @emit-word2
  !word-buffer !emit-word-cursor @ !+w + b@ emit
  !emit-word-cursor !!+1
  const -1 cjmp @emit-word1
  :emit-word2
.end

.codeword pow
  dup const 0 = cjmp @pow-1
  swap dup rput swap
:pow-loop
  dup const 2 < cjmp @pow-end
  swap
  rpop dup rput *
  swap const 1 -
  const -1 cjmp @pow-loop
:pow-end
  drop
  rpop
  drop
  ret
:pow-1
  drop
  drop
  const 1
.end

.codeword number?
  dup const 47 > & const 58 <
.end

.codeword negative-number?
  !word-buffer !+w b@
  const 45 =
.end

.codeword unit
  cjmp @unit-t
  const 1
  ret
:unit-t
  const -1
.end

.codeword minus?
  const 45 =
.end

.codeword number
  !negative-number?
  dup const -1 * rput	( Skip the first char if it is '-' )
  !unit	       	 	( 1 or -1 if '-' )
  const 0		( Init result )
:number-loop
  !word-buffer !+w r@ + b@				( Read char at offset r@ )
  dup !number? ~ cjmp @number-err
  const 48 -
  const 10 !word-buffer @ const 1 - r@ - !pow * +	( Scale digit at offset )
  rpop const 1 + rput
  r@ !word-buffer @ < cjmp @number-loop
  *  		  ( Negate if word started with '-' )
  const 0	  ( 0 to indicate no error )
  rpop drop
  ret
:number-err
  drop drop drop	( Cleanup )
  rpop drop
  const -1		( -1 to indicate error )
.end

.codeword digit-to-char
  const 10 %	( Get last digit )
  const 48 +	( Add '0' to it )
.end

.codeword digit-count
  dup const -1 > const 1 +
  swap
  
:digit-count-loop
  swap const 1 + swap
  const 10 /
  dup const 0 = ~ cjmp @digit-count-loop
  drop
.end

.codeword last-digit-to-word
  dup dup
  !digit-count const 1 -
  swap !digit-to-char
  swap !+w !word-buffer + b!
  const 10 /
.end
.codeword number-to-word
  dup !digit-count	( Get number of digits )
  !word-buffer !  	( Store future len in word-buffer )

:number-to-word-loop
  !last-digit-to-word
  dup const 0 > cjmp @number-to-word-loop

  drop !word-buffer
.end

( Built-in variables )
.var state 0 .end
.var here @here-label .end
.var base 10 .end

( Built-in constants
# VERSION         Is the current version of this FORTH.
# R0              The +ress of the top of the return stack.
# DOCOL           Pointer to DOCOL.
# F_IMMED         The IMMEDIATE flag's actual value.
# F_HIDDEN        The HIDDEN flag's actual value.
# F_LENMASK       The length mask in the flags/len byte.
)

.const konstantin 77 .end

( .codeword main !word drop !emit-word exit .end )
( .codeword main const 10 const 6 !pow .end )
.codeword main !word drop const 9999 drop !number drop .end
( .codeword main const 34 !number-to-word
  !word-buffer @
(  !word-buffer !+w b@ emit )
(  !word-buffer !+w const 1 + b@ emit )
  !emit-word
.end )

( No word definition shall stand beyond this mark. )
( Except this one. )
.var latest @latest .end

:start
call
@_dictmain
exit

( TODO:
- Support label references for .const & .var
- Define .var here @end .end
- Define .var latest @_dictlatest (?) .end
- Rename @r to rdup
- Remove "!" macro and insert calls when it is not a instruction
- Implement "find"
)

( No code shall reach beyond this point or it will be overwritten. )
:here-label
