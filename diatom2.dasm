const
-1
cjmp
@start

( Machine words )
.codeword +w const 4 + .end
.codeword !+1 dup @ const 1 + swap ! .end

( Reserve 11 bytes for the buffer of our 'word' word. )
.var word-buffer 0 .end
nop nop nop nop
nop nop nop nop
nop nop
.var word-cursor 0 .end

.codeword reset-word-cursor const 0 !word-cursor ! .end
.codeword store-in-word
  !word-buffer !word-cursor @ !+w + b!
  !word-cursor !!+1
.end
.codeword finish-word !word-cursor @ !word-buffer ! !reset-word-cursor .end
.codeword is-blank? const 32 = .end
.codeword non-blank-key
  key dup const 32 = ~ cjmp @nbk1
  drop const -1 cjmp @_dictnon-blank-key :nbk1
.end
.codeword word
  !non-blank-key
  :word1 !store-in-word
  key dup !is-blank? ~ cjmp @word1
  drop !finish-word !word-buffer
.end

.var emit-word-cursor 0 .end
.codeword reset-emit-word-cursor const 0 !emit-word-cursor ! .end
.codeword emit-word
  !reset-emit-word-cursor
  :emit-word1 !word-buffer @ !emit-word-cursor @ > ~ cjmp @emit-word2
  !word-buffer !emit-word-cursor @ !+w + b@ emit
  !emit-word-cursor !!+1
  const -1 cjmp @emit-word1
  :emit-word2
.end

.codeword pow
  dup const 0 = cjmp @pow-1
  swap dup rput swap
:pow-loop
  dup const 2 < cjmp @pow-end
  swap
  rpop dup rput *
  swap const 1 -
  const -1 cjmp @pow-loop
:pow-end
  drop
  rpop
  drop
  ret
:pow-1
  drop
  drop
  const 1
.end

.codeword number?
  dup const 47 > & const 58 <
.end

.codeword number
  const 0 rput		( Init loop counter )
  const 0 		( Init result )
( TODO: Handle negative numbers )
:number-loop
  !word-buffer @ r@ - const 1 -	( Calculate offset )
  !word-buffer !+w + b@	( Fetch char )
  dup !number? ~ cjmp @number-err
  const 48 -   	 	( Convert to numeric value )
  const 10 r@ !pow * +	( Add value to result )
  rpop const 1 + rput	( Increase loop counter )
  r@ !word-buffer @ < cjmp @number-loop
  const 0      	     	( Indicate no error )
  rpop drop
  ret
:number-err
  drop drop
  const -1
  rpop drop
.end

.codeword digit-to-char
  const 10 %	( Get last digit )
  const 48 +	( Add '0' to it )
.end

.codeword digit-count
  dup const -1 > const 1 +
  swap
  
:digit-count-loop
  swap const 1 + swap
  const 10 /
  dup const 0 = ~ cjmp @digit-count-loop
  drop
.end

.codeword last-digit-to-word
  dup dup
  !digit-count const 1 -
  swap !digit-to-char
  swap !+w !word-buffer + b!
  const 10 /
.end
.codeword number-to-word
  dup !digit-count	( Get number of digits )
  !word-buffer !  	( Store future len in word-buffer )

:number-to-word-loop
  !last-digit-to-word
  dup const 0 > cjmp @number-to-word-loop

  drop !word-buffer
.end

( Built-in variables )
.var state 0 .end
.var latest 0 .end
.var here 0 .end
.var base 10 .end

( Built-in constants
# VERSION         Is the current version of this FORTH.
# R0              The +ress of the top of the return stack.
# DOCOL           Pointer to DOCOL.
# F_IMMED         The IMMEDIATE flag's actual value.
# F_HIDDEN        The HIDDEN flag's actual value.
# F_LENMASK       The length mask in the flags/len byte.
)

.const konstantin 77 .end

( .codeword main !word drop !emit-word exit .end )
( .codeword main const 10 const 6 !pow .end )
.codeword main !word drop const 9999 drop !number drop .end
( .codeword main const 34 !number-to-word
  !word-buffer @
(  !word-buffer !+w b@ emit )
(  !word-buffer !+w const 1 + b@ emit )
  !emit-word
.end )

( TODO: Fix emit-word :( )
	   	
:start
call
@_dictmain
exit