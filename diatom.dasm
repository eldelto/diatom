const
@start
jump

# Machine words
.codeword exit exit
.codeword nop nop
.codeword @ fetch
.codeword ! store
.codeword + add
.codeword - subtract
.codeword * multiply
.codeword / divide
.codeword dup dup
.codeword drop drop
.codeword swap swap
.codeword over over
.codeword jump jump
.codeword call call
.codeword ; return
.codeword key key
.codeword emit emit
.codeword = equals
.codeword jumpif jumpif
.codeword not not

# Reserve 11 bytes for the buffer of our 'word' word.
.var word-buffer 0
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
.var word-cursor 0

.colonword word-cursor+1 word-cursor dup @ 1 + word-cursor !
.colonword reset-word-cursor 0 word-cursor !
.colonword store-in-word word-buffer word-cursor+1 + !
.colonword finish-word word-cursor @ word-buffer ! reset-word-cursor
.codeword is-blank? const 32 equals
.codeword non-blank-key key dup const 32 equals not @nbk1 swap jumpif drop @_dictnon-blank-key jump :nbk1
# TODO: Re-write as colonword.
.colonword word non-blank-key :word1 store-in-word key dup is-blank? not @word1 swap jumpif store-in-word finish-word word-buffer

# Built-in variables
.var state 0
.var latest 0
.var here 0
.var base 10

# Built-in constants
# VERSION         Is the current version of this FORTH.
# R0              The address of the top of the return stack.
# DOCOL           Pointer to DOCOL.
# F_IMMED         The IMMEDIATE flag's actual value.
# F_HIDDEN        The HIDDEN flag's actual value.
# F_LENMASK       The length mask in the flags/len byte.

# Assembly words

# .colonword word ???

# Test stuff
.var beast 666
.const one 1

.colonword add-x beast @ + one +
.colonword double dup +
.colonword quadruple double double
.colonword main word 1 + @ emit


:test
	call
	@_dictadd-x
	call
	@_dictquadruple
	const
	65
	emit
	call
	@_dictnon-blank-key
	emit
	exit
	
:start
call
@_dictmain
exit